"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
else{
Imputed$Primary_diet <- NA
Imputed$sqrt_Diet_breadth <- NA
Imputed <- Imputed[, c("Order", "Family", "Genus", "Best_guess_binomial",
"log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Diel_activity", "Specialisation","Trophic_level", "sqrt_Diet_breadth", "Primary_diet",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
## Return
ToReturn <- list(Imputed.Dataset=Imputed, Imputation.errors=Errors)
ToReturn <- list(ToReturn)
names(ToReturn) <- Class
return(ToReturn)
}
View(Test1)
View(Test1)
Class.List <- list("Mammals", "Birds", "Reptiles", "Amphibians")
Class.List
## to test: this function and also the apply version calling this one
Test1 <- pbmapply (FUN=Imputations_missForest,
TraitDF=DF.TraitsList,
Taxinfo=Taxinfo,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
View(Test1)
X <- Test1[[1]]
View(X)
X <- Test1[[1]]$Imputed.Dataset
View(X)
Imputations_missForest <- function (TraitDF, Taxinfo, Traits_cont, Traits_cat, EV, ErrorTrue, DietTRUE, Class) {
## Select traits of interest, to impute, and phylogenetic eigenvectors, and taxinfo
To_impute <- TraitDF[, colnames(TraitDF) %in% c(Taxinfo, Traits_cont, Traits_cat, EV)]
rownames(To_impute) <- TraitDF$Best_guess_binomial
## Set habitat and diet variables as binary (TRUE for 1 and FALSE for 0)
## Set class as numeric for all continuous traits
To_impute[, Traits_cont] <- apply(To_impute[, Traits_cont], 2, as.numeric)
## Set habitat and diet variables as factors. Otherwise, when they are numeric or logical, outputs are numeric
if(DietTRUE){
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
for (i in Diet) {
To_impute[,i] <- factor(To_impute[,i], levels=c(0,1))
}
}
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
for (i in Habitat) {
To_impute[,i] <- factor(To_impute[,i], levels=c(0,1))
}
## Impute missing values
print("Imputing missing values.")
if (isTRUE(ErrorTrue)) { R.Imputed <- missForest(To_impute, variablewise = TRUE) }
else { R.Imputed <- missForest(To_impute, variablewise = FALSE) }
Imputed <- R.Imputed$ximp
Errors <- R.Imputed$OOBerror
## Select traits and variables of interest
if(DietTRUE) {
Continuous <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", "sqrt_Diet_breadth")
Categorical <- c(Habitat, "Specialisation", "Diel_activity","Trophic_level", Diet)
}
else{
Continuous <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Categorical <- c(Habitat, "Specialisation", "Diel_activity","Trophic_level")}
Imputed$Best_guess_binomial <- rownames(Imputed)
Imputed <- Imputed[order(Imputed$Best_guess_binomial), c(Taxinfo, "Best_guess_binomial", Continuous, Categorical, "EV_1")]
## Add a column for phylogenetic information (yes or no)
Imputed$Phylo_info <- TraitDF$EV_1
Imputed$Phylo_info[!is.na(Imputed$Phylo_info)] <- "YES"
Imputed$Phylo_info[is.na(Imputed$Phylo_info)] <- "NO"
## Add taxonomic information
Imputed$Order <- TraitDF$Order
Imputed$Family <- TraitDF$Family
Imputed$Genus <- TraitDF$Genus
## Reprocess Primary diet and diet breadth (sqrt + normalise) if diet is included
## Then reorder columns.
if(DietTRUE){
Func <- function(X) {
names(X) <- Diet
ToPaste <- names(X)[which(X==1)]
return(paste(ToPaste, collapse = "|"))
}
Imputed$Primary_diet <- apply(Imputed[,Diet], 1, Func)
Imputed[, Diet] <- apply(Imputed[, Diet], 2, as.numeric)
Imputed$sqrt_Diet_breadth_reprocessed <- apply(Imputed[, Diet], 1, sum, na.rm=T) %>% sqrt()
Imputed <- Imputed[, c("Order", "Family", "Genus", "Best_guess_binomial",
"log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Diel_activity", "Specialisation",
"Trophic_level", "sqrt_Diet_breadth", "sqrt_Diet_breadth_reprocessed","Primary_diet", Diet,
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
else{
Imputed$Primary_diet <- NA
Imputed$sqrt_Diet_breadth <- NA
Imputed <- Imputed[, c("Order", "Family", "Genus", "Best_guess_binomial",
"log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Diel_activity", "Specialisation","Trophic_level", "sqrt_Diet_breadth", "Primary_diet",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
rownames(Imputed) <- c(1:nrow(Imputed))
## Return
ToReturn <- list(Imputed.Dataset=Imputed, Imputation.errors=Errors)
ToReturn <- list(ToReturn)
names(ToReturn) <- Class
return(ToReturn)
}
## to test: this function and also the apply version calling this one
Test1 <- pbmapply (FUN=Imputations_missForest,
TraitDF=DF.TraitsList,
Taxinfo=Taxinfo,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
X <- Test1[[1]]$Imputed.Dataset
View(X)
colnames(X)
# List of function arguments. This list  will be replicated 8 times (number of cores) for parallel imputations.
# On each cluster, imputation of 4 datasets (one for each class).
ArgumentsList <- list(TraitDF=DF.TraitsList,
Taxinfo=Taxinfo.List,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
Test2 <- To_apply_parallel_imputations(ArgumentsList)
## Function to apply in parallel (runs the aboce function Imputations_missForest)
To_apply_parallel_imputations <- function (List_of_arguments) {
## NB: which function to use here on windows to replace pbmapply (or mapply)?
## mapply only works with forking methods (unix or linux)
Imputations_results <- pbmapply (FUN=Imputations_missForest,
TraitDF=List_of_arguments[["TraitDF"]],
Taxinfo=List_of_arguments[["Taxinfo"]],
Traits_cont=List_of_arguments[["Traits_cont"]],
Traits_cat=List_of_arguments[["Traits_cat"]],
EV=List_of_arguments[["EV"]],
ErrorTrue=List_of_arguments[["ErrorTrue"]],
DietTRUE=List_of_arguments[["DietTRUE"]],
Class=List_of_arguments[["Class"]])
return (Imputations_results)
}
Test2 <- To_apply_parallel_imputations(ArgumentsList)
View(Test2)
Class.List
## Preamble
X <- c("dplyr", "phytools", "missForest", "pbapply")
lapply(X, library, character.only=TRUE); rm(X)
`%nin%` <- Negate(`%in%`)
source("Functions_for_missForest_imputations.R")
## Load trait data, transformed, standardised, and with phylogenetic imformation
Mammals <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Mammals.csv")
Birds <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Birds.csv")
Amphibians <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Amphibians.csv")
Reptiles <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Reptiles.csv")
Mammals <- Mammals[c(1:10),]
Amphibians <- Amphibians[c(1:10),]
Birds <- Birds[c(1:10),]
Reptiles <- Reptiles[c(1:10),]
## Define variables for imputations
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
Taxinfo <- "Order"
Traits_cont <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size", "sqrt_Diet_breadth",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Traits_cat <- c(Habitat, "Specialisation",        # Include diet now or derive later from imputed primary diet?
"Diel_activity","Trophic_level", Diet)
#EV <- c(); for(i in 1:10) {EV <- c(EV,paste("EV_",i, sep=""))}
## Add some traits for each taxon # TODO check trait names
MammalsCont <- c(Traits_cont, "log10_Generation_length_d", "log10_Adult_svl_cm")
BirdsCont <- Traits_cont
ReptilesCont <- c(Traits_cont, "log10_Adult_svl_cm", "log10_Maturity_d")
AmphibiansCont <- c(Traits_cont, "log10_Body_length_mm")
## Function arguments as lists, nested into one bigger list - each of these list elements are agurments for the function Imputations_missForest
DF.TraitsList <- list(M=Mammals, B=Birds, R=Reptiles, A=Amphibians)
Taxinfo.List <- list(M="Order", B="Order", R="Order", A="Order")
Cont.TraitsList <- list(M=MammalsCont, B=BirdsCont, R=ReptilesCont, A=AmphibiansCont)
Cat.TraitsList <- list(M=Traits_cat, B=Traits_cat, R=Traits_cat[Traits_cat %nin% Diet], A=Traits_cat)
EV.List <- list(M="EV_1", B="EV_1", R="EV_1", A="EV_1")
ErrorTrue.List <- list(M=TRUE, B=TRUE, R=TRUE, A=TRUE)
DietTRUE.List <- list(M=TRUE, B=TRUE, R=FALSE, A=TRUE)
Class.List <- list("Mammals", "Birds", "Reptiles", "Amphibians")
# List of function arguments. This list  will be replicated 8 times (number of cores) for parallel imputations.
# On each cluster, imputation of 4 datasets (one for each class).
ArgumentsList <- list(TraitDF=DF.TraitsList,
Taxinfo=Taxinfo.List,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
library(parallel)
ArgumentsList
## to test: this function and also the apply version calling this one
Test1 <- pbmapply (FUN=Imputations_missForest,
TraitDF=DF.TraitsList,
Taxinfo=Taxinfo,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
Test2 <- To_apply_parallel_imputations(ArgumentsList)
View(Test2)
Imputations_missForest <- function (TraitDF, Taxinfo, Traits_cont, Traits_cat, EV, ErrorTrue, DietTRUE, Class) {
## Select traits of interest, to impute, and phylogenetic eigenvectors, and taxinfo
To_impute <- TraitDF[, colnames(TraitDF) %in% c(Taxinfo, Traits_cont, Traits_cat, EV)]
rownames(To_impute) <- TraitDF$Best_guess_binomial
## Set habitat and diet variables as binary (TRUE for 1 and FALSE for 0)
## Set class as numeric for all continuous traits
To_impute[, Traits_cont] <- apply(To_impute[, Traits_cont], 2, as.numeric)
## Set habitat and diet variables as factors. Otherwise, when they are numeric or logical, outputs are numeric
if(DietTRUE){
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
for (i in Diet) {
To_impute[,i] <- factor(To_impute[,i], levels=c(0,1))
}
}
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
for (i in Habitat) {
To_impute[,i] <- factor(To_impute[,i], levels=c(0,1))
}
## Impute missing values
print("Imputing missing values.")
if (isTRUE(ErrorTrue)) { R.Imputed <- missForest(To_impute, variablewise = TRUE) }
else { R.Imputed <- missForest(To_impute, variablewise = FALSE) }
Imputed <- R.Imputed$ximp
Errors <- R.Imputed$OOBerror
## Select traits and variables of interest
if(DietTRUE) {
Continuous <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", "sqrt_Diet_breadth")
Categorical <- c(Habitat, "Specialisation", "Diel_activity","Trophic_level", Diet)
}
else{
Continuous <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Categorical <- c(Habitat, "Specialisation", "Diel_activity","Trophic_level")}
Imputed$Best_guess_binomial <- rownames(Imputed)
Imputed <- Imputed[order(Imputed$Best_guess_binomial), c(Taxinfo, "Best_guess_binomial", Continuous, Categorical, "EV_1")]
## Add a column for phylogenetic information (yes or no)
Imputed$Phylo_info <- TraitDF$EV_1
Imputed$Phylo_info[!is.na(Imputed$Phylo_info)] <- "YES"
Imputed$Phylo_info[is.na(Imputed$Phylo_info)] <- "NO"
## Add taxonomic information
Imputed$Order <- TraitDF$Order
Imputed$Family <- TraitDF$Family
Imputed$Genus <- TraitDF$Genus
## Reprocess Primary diet and diet breadth (sqrt + normalise) if diet is included
## Then reorder columns.
if(DietTRUE){
Func <- function(X) {
names(X) <- Diet
ToPaste <- names(X)[which(X==1)]
return(paste(ToPaste, collapse = "|"))
}
Imputed$Primary_diet <- apply(Imputed[,Diet], 1, Func)
Imputed[, Diet] <- apply(Imputed[, Diet], 2, as.numeric)
Imputed$sqrt_Diet_breadth_reprocessed <- apply(Imputed[, Diet], 1, sum, na.rm=T) %>% sqrt()
Imputed <- Imputed[, c("Order", "Family", "Genus", "Best_guess_binomial",
"log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Diel_activity", "Specialisation",
"Trophic_level", "sqrt_Diet_breadth", "sqrt_Diet_breadth_reprocessed","Primary_diet", Diet,
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
else{
Imputed$Primary_diet <- NA
Imputed$sqrt_Diet_breadth <- NA
Imputed <- Imputed[, c("Order", "Family", "Genus", "Best_guess_binomial",
"log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size",
"Diel_activity", "Specialisation","Trophic_level", "sqrt_Diet_breadth", "Primary_diet",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN", Habitat)]
}
rownames(Imputed) <- c(1:nrow(Imputed))
## Return
ToReturn <- list(Imputed.Dataset=Imputed, Imputation.errors=Errors)
ToReturn <- list(ToReturn)
# names(ToReturn) <- Class
return(ToReturn)
}
Test2 <- To_apply_parallel_imputations(ArgumentsList)
View(Test2)
View(Test2)
library(parallel)
# # ## START CLUSTER
Cluster <- makeCluster(detectCores())
## EXCECUTE ANY PRE PROCESSING CODE NECESSARY
clusterEvalQ(Cluster, {
library(dplyr)
library(phytools)
library(missForest)
library(pbmcapply)
library(pbapply)
})
# ## Preamble
# X <- c("dplyr", "phytools", "missForest", "pbapply")
# lapply(X, library, character.only=TRUE); rm(X)
`%nin%` <- Negate(`%in%`)
source("Functions_for_missForest_imputations.R")
Mammals <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Mammals.csv")
Birds <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Birds.csv")
Amphibians <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Amphibians.csv")
Reptiles <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Reptiles.csv")
Mammals <- Mammals[c(1:10),]
Amphibians <- Amphibians[c(1:10),]
Birds <- Birds[c(1:10),]
Reptiles <- Reptiles[c(1:10),]
## Define variables for imputations
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
Taxinfo <- "Order"
Traits_cont <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size", "sqrt_Diet_breadth",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Traits_cat <- c(Habitat, "Specialisation",        # Include diet now or derive later from imputed primary diet?
"Diel_activity","Trophic_level", Diet)
#EV <- c(); for(i in 1:10) {EV <- c(EV,paste("EV_",i, sep=""))}
## Add some traits for each taxon # TODO check trait names
MammalsCont <- c(Traits_cont, "log10_Generation_length_d", "log10_Adult_svl_cm")
BirdsCont <- Traits_cont
ReptilesCont <- c(Traits_cont, "log10_Adult_svl_cm", "log10_Maturity_d")
AmphibiansCont <- c(Traits_cont, "log10_Body_length_mm")
## Function arguments as lists, nested into one bigger list - each of these list elements are agurments for the function Imputations_missForest
DF.TraitsList <- list(M=Mammals, B=Birds, R=Reptiles, A=Amphibians)
Taxinfo.List <- list(M="Order", B="Order", R="Order", A="Order")
Cont.TraitsList <- list(M=MammalsCont, B=BirdsCont, R=ReptilesCont, A=AmphibiansCont)
Cat.TraitsList <- list(M=Traits_cat, B=Traits_cat, R=Traits_cat[Traits_cat %nin% Diet], A=Traits_cat)
EV.List <- list(M="EV_1", B="EV_1", R="EV_1", A="EV_1")
ErrorTrue.List <- list(M=TRUE, B=TRUE, R=TRUE, A=TRUE)
DietTRUE.List <- list(M=TRUE, B=TRUE, R=FALSE, A=TRUE)
Class.List <- list("Mammals", "Birds", "Reptiles", "Amphibians")
# List of function arguments. This list  will be replicated 8 times (number of cores) for parallel imputations.
# On each cluster, imputation of 4 datasets (one for each class).
ArgumentsList <- list(TraitDF=DF.TraitsList,
Taxinfo=Taxinfo.List,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
# Replicate this list N times so that: list with N elements, each of these are ArgumentsLists
N <- 8
To_impute_parallel <- rep(list(ArgumentsLists), N)
To_impute_parallel <- rep(list(ArgumentsList), N)
View(To_impute_parallel)
rm(Mammals, Birds, Reptiles, Amphibians,
Habitat, Diet, Taxinfo, Traits_cont, Traits_cat,
MammalsCont, BirdsCont, ReptilesCont, AmphibiansCont,
DF.TraitsList, Taxinfo.List, Cont.TraitsList, Cat.TraitsList,
EV.List, ErrorTrue.List, DietTRUE.List)
rm(Mammals, Birds, Reptiles, Amphibians,
Habitat, Diet, Taxinfo, Traits_cont, Traits_cat,
MammalsCont, BirdsCont, ReptilesCont, AmphibiansCont,
DF.TraitsList, Taxinfo.List, Cont.TraitsList, Cat.TraitsList,
EV.List, ErrorTrue.List, DietTRUE.List, N)
rm(Mammals, Birds, Reptiles, Amphibians,
Habitat, Diet, Taxinfo, Traits_cont, Traits_cat,
MammalsCont, BirdsCont, ReptilesCont, AmphibiansCont,
DF.TraitsList, Taxinfo.List, Cont.TraitsList, Cat.TraitsList,
EV.List, ErrorTrue.List, DietTRUE.List, Class.List, N)
## Export variables in all clusters
clusterExport(cl=Cluster, list("Imputations_missForest",
"To_apply_parallel_imputations",
"To_impute_parallel",
"%nin%"), envir=environment())
## Parallel imputations on 8 cores
Imputed_sets_8 <- parLapply(cl=Cluster,
X=To_impute_parallel,
fun=To_apply_parallel_imputations)
View(Imputed_sets_8)
## Save results
saveRDS(Imputed_sets_8, "../../Results/2.imputed_trait_datasets/imputed_datasets/List_8_imputed_sets.rds")
## DESTROY CLUSTER
stopCluster(Cluster)
library(parallel)
# ## Preamble
# X <- c("dplyr", "phytools", "missForest", "pbapply")
# lapply(X, library, character.only=TRUE); rm(X)
`%nin%` <- Negate(`%in%`)
source("Functions_for_missForest_imputations.R")
Mammals <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Mammals.csv")
Birds <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Birds.csv")
Amphibians <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Amphibians.csv")
Reptiles <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Reptiles.csv")
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
Taxinfo <- "Order"
Traits_cont <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size", "sqrt_Diet_breadth",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Traits_cat <- c(Habitat, "Specialisation",        # Include diet now or derive later from imputed primary diet?
"Diel_activity","Trophic_level", Diet)
#EV <- c(); for(i in 1:10) {EV <- c(EV,paste("EV_",i, sep=""))}
## Add some traits for each taxon # TODO check trait names
MammalsCont <- c(Traits_cont, "log10_Generation_length_d", "log10_Adult_svl_cm")
BirdsCont <- Traits_cont
ReptilesCont <- c(Traits_cont, "log10_Adult_svl_cm", "log10_Maturity_d")
AmphibiansCont <- c(Traits_cont, "log10_Body_length_mm")
## Function arguments as lists, nested into one bigger list - each of these list elements are agurments for the function Imputations_missForest
DF.TraitsList <- list(M=Mammals, B=Birds, R=Reptiles, A=Amphibians)
Taxinfo.List <- list(M="Order", B="Order", R="Order", A="Order")
Cont.TraitsList <- list(M=MammalsCont, B=BirdsCont, R=ReptilesCont, A=AmphibiansCont)
Cat.TraitsList <- list(M=Traits_cat, B=Traits_cat, R=Traits_cat[Traits_cat %nin% Diet], A=Traits_cat)
EV.List <- list(M="EV_1", B="EV_1", R="EV_1", A="EV_1")
ErrorTrue.List <- list(M=TRUE, B=TRUE, R=TRUE, A=TRUE)
DietTRUE.List <- list(M=TRUE, B=TRUE, R=FALSE, A=TRUE)
Class.List <- list("Mammals", "Birds", "Reptiles", "Amphibians")
# List of function arguments. This list  will be replicated 8 times (number of cores) for parallel imputations.
# On each cluster, imputation of 4 datasets (one for each class).
ArgumentsList <- list(TraitDF=DF.TraitsList,
Taxinfo=Taxinfo.List,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List,
Class=Class.List)
Imputed_set_1 <- To_apply_parallel_imputations(ArgumentsList)
library(parallel)
# # ## START CLUSTER
Cluster <- makeCluster(detectCores())
## EXCECUTE ANY PRE PROCESSING CODE NECESSARY
clusterEvalQ(Cluster, {
library(dplyr)
library(phytools)
library(missForest)
library(pbmcapply)
library(pbapply)
})
# ## Preamble
# X <- c("dplyr", "phytools", "missForest", "pbapply")
# lapply(X, library, character.only=TRUE); rm(X)
`%nin%` <- Negate(`%in%`)
source("Functions_for_missForest_imputations.R")
Mammals <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Mammals.csv")
Birds <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Birds.csv")
Amphibians <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Amphibians.csv")
Reptiles <- read.csv("../../Results/1.Traits_before_imputations/With_taxonomic_correction/All_species/4.with_phylo_eigenvectors/Reptiles.csv")
Habitat <- c("Forest","Savanna","Shrubland","Grassland","Wetland","Rocky.areas","Caves.and.subterranean",
"Desert","Marine","Marine.intertidal.or.coastal.supratidal",
"Artificial","Introduced.vegetation","Other.Unknown")
Diet <- c("IN", "VE", "PL", "SE", "NE", "FR", "SCV")
Taxinfo <- "Order"
Traits_cont <-  c("log10_Body_mass_g", "log10_Longevity_d", "log10_Litter_size", "sqrt_Diet_breadth",
"Range_size_m2", "sqrt_Habitat_breadth_IUCN")
Traits_cat <- c(Habitat, "Specialisation",        # Include diet now or derive later from imputed primary diet?
"Diel_activity","Trophic_level", Diet)
MammalsCont <- c(Traits_cont, "log10_Generation_length_d", "log10_Adult_svl_cm")
BirdsCont <- Traits_cont
ReptilesCont <- c(Traits_cont, "log10_Adult_svl_cm", "log10_Maturity_d")
AmphibiansCont <- c(Traits_cont, "log10_Body_length_mm")
DF.TraitsList <- list(M=Mammals, B=Birds, R=Reptiles, A=Amphibians)
Taxinfo.List <- list(M="Order", B="Order", R="Order", A="Order")
Cont.TraitsList <- list(M=MammalsCont, B=BirdsCont, R=ReptilesCont, A=AmphibiansCont)
Cat.TraitsList <- list(M=Traits_cat, B=Traits_cat, R=Traits_cat[Traits_cat %nin% Diet], A=Traits_cat)
EV.List <- list(M="EV_1", B="EV_1", R="EV_1", A="EV_1")
ErrorTrue.List <- list(M=TRUE, B=TRUE, R=TRUE, A=TRUE)
DietTRUE.List <- list(M=TRUE, B=TRUE, R=FALSE, A=TRUE)
# List of function arguments. This list  will be replicated 8 times (number of cores) for parallel imputations.
# On each cluster, imputation of 4 datasets (one for each class).
ArgumentsList <- list(TraitDF=DF.TraitsList,
Taxinfo=Taxinfo.List,
Traits_cont=Cont.TraitsList,
Traits_cat=Cat.TraitsList,
EV=EV.List,
ErrorTrue=ErrorTrue.List,
DietTRUE=DietTRUE.List)
# Replicate this list N times so that: list with N elements, each of these are ArgumentsLists
N <- 8
To_impute_parallel <- rep(list(ArgumentsList), N)
rm(Mammals, Birds, Reptiles, Amphibians,
Habitat, Diet, Taxinfo, Traits_cont, Traits_cat,
MammalsCont, BirdsCont, ReptilesCont, AmphibiansCont,
DF.TraitsList, Taxinfo.List, Cont.TraitsList, Cat.TraitsList,
EV.List, ErrorTrue.List, DietTRUE.List, N)
View(To_impute_parallel)
rm(Mammals, Birds, Reptiles, Amphibians,
Habitat, Diet, Taxinfo, Traits_cont, Traits_cat,
MammalsCont, BirdsCont, ReptilesCont, AmphibiansCont,
DF.TraitsList, Taxinfo.List, Cont.TraitsList, Cat.TraitsList,
EV.List, ErrorTrue.List, DietTRUE.List, N,
ArgumentsList)
## Export variables in all clusters
clusterExport(cl=Cluster, list("Imputations_missForest",
"To_apply_parallel_imputations",
"To_impute_parallel",
"%nin%"), envir=environment())
## Parallel imputations on 8 cores
Imputed_sets <- parLapply(cl=Cluster,
X=To_impute_parallel,
fun=To_apply_parallel_imputations)
## DESTROY CLUSTER
stopCluster(Cluster)
